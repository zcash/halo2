use halo2_proofs::arithmetic::FieldExt;

use super::{grain::Grain, Mds};

pub(super) fn generate_mds<F: FieldExt, const T: usize>(
    grain: &mut Grain<F>,
    mut select: usize,
) -> (Mds<F, T>, Mds<F, T>) {
    let (xs, ys, mds) = loop {
        // Generate two [F; T] arrays of unique field elements.
        let (xs, ys) = loop {
            let mut vals: Vec<_> = (0..2 * T)
                .map(|_| grain.next_field_element_without_rejection())
                .collect();

            // Check that we have unique field elements.
            let mut unique = vals.clone();
            unique.sort_unstable();
            unique.dedup();
            if vals.len() == unique.len() {
                let rhs = vals.split_off(T);
                break (vals, rhs);
            }
        };

        // We need to ensure that the MDS is secure. Instead of checking the MDS against
        // the relevant algorithms directly, we witness a fixed number of MDS matrices
        // that we need to sample from the given Grain state before obtaining a secure
        // matrix. This can be determined out-of-band via the reference implementation in
        // Sage.
        if select != 0 {
            select -= 1;
            continue;
        }

        // Generate a Cauchy matrix, with elements a_ij in the form:
        //     a_ij = 1/(x_i + y_j); x_i + y_j != 0
        //
        // It would be much easier to use the alternate definition:
        //     a_ij = 1/(x_i - y_j); x_i - y_j != 0
        //
        // These are clearly equivalent on `y <- -y`, but it is easier to work with the
        // negative formulation, because ensuring that xs âˆª ys is unique implies that
        // x_i - y_j != 0 by construction (whereas the positive case does not hold). It
        // also makes computation of the matrix inverse simpler below (the theorem used
        // was formulated for the negative definition).
        //
        // However, the Poseidon paper and reference impl use the positive formulation,
        // and we want to rely on the reference impl for MDS security, so we use the same
        // formulation.
        let mut mds = [[F::zero(); T]; T];
        #[allow(clippy::needless_range_loop)]
        for i in 0..T {
            for j in 0..T {
                let sum = xs[i] + ys[j];
                // We leverage the secure MDS selection counter to also check this.
                assert!(!sum.is_zero_vartime());
                mds[i][j] = sum.invert().unwrap();
            }
        }

        break (xs, ys, mds);
    };

    // Compute the inverse. All square Cauchy matrices have a non-zero determinant and
    // thus are invertible. The inverse for a Cauchy matrix of the form:
    //
    //     a_ij = 1/(x_i - y_j); x_i - y_j != 0
    //
    // has elements b_ij given by:
    //
    //     b_ij = (x_j - y_i) A_j(y_i) B_i(x_j)    (Schechter 1959, Theorem 1)
    //
    // where A_i(x) and B_i(x) are the Lagrange polynomials for xs and ys respectively.
    //
    // We adapt this to the positive Cauchy formulation by negating ys.
    let mut mds_inv = [[F::zero(); T]; T];
    let l = |xs: &[F], j, x: F| {
        let x_j = xs[j];
        xs.iter().enumerate().fold(F::one(), |acc, (m, x_m)| {
            if m == j {
                acc
            } else {
                // We can invert freely; by construction, the elements of xs are distinct.
                acc * (x - x_m) * (x_j - x_m).invert().unwrap()
            }
        })
    };
    let neg_ys: Vec<_> = ys.iter().map(|y| -*y).collect();
    for i in 0..T {
        for j in 0..T {
            mds_inv[i][j] = (xs[j] - neg_ys[i]) * l(&xs, j, neg_ys[i]) * l(&neg_ys, i, xs[j]);
        }
    }

    (mds, mds_inv)
}

#[cfg(test)]
mod tests {
    use pasta_curves::Fp;

    use super::{generate_mds, Grain};

    #[test]
    fn compare_against_test_vector() {
        // These are generated by
        //   sage generate_parameters_grain.sage 1 0 255 3 8 56 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001
        // using <https://github.com/daira/pasta-hadeshash/a1a41a30ff486d247ebc44a831457c5e393374af/master/code/generate_parameters_grain.sage>.
        let mds_testvector = [
            // First row
            [
                Fp::from_raw([0x323f_2486_d7e1_1b63, 0x97d7_a0ab_2385_0b56, 0xb3d5_9fbd_c8c9_ead4, 0x0ab5_e5b8_74a6_8de7]),
                Fp::from_raw([0x8eca_5596_e996_ab5e, 0x240d_4a7c_bf73_5736, 0x293f_0f0d_886c_7954, 0x3191_6628_e58a_5abb]),
                Fp::from_raw([0x19d1_cf25_d8e8_345d, 0xa0a3_b71a_5fb1_5735, 0xd803_952b_bb36_4fdf, 0x07c0_45d5_f5e9_e5a6])
            ],
            // Second row
            [
                Fp::from_raw([0xd049_cdc8_d085_167c, 0x3a0a_4640_48bd_770a, 0xf8e2_4f66_822c_2d9f, 0x2331_6263_0ebf_9ed7]),
                Fp::from_raw([0x4022_7011_3e04_7a2e, 0x78f8_365c_85bb_ab07, 0xb366_6454_8d60_957d, 0x25ca_e259_9892_a8b0]),
                Fp::from_raw([0xf84d_806f_685f_747a, 0x9aad_3d82_62ef_d83f, 0x7493_8717_989a_1957, 0x22f5_b5e1_e608_1c97])
            ],
            // Third row
            [
                Fp::from_raw([0xfee7_a994_4f84_dbe4, 0x2168_0eab_c56b_c15d, 0xf333_aa91_c383_3464, 0x2e29_dd59_c64b_1037]),
                Fp::from_raw([0xc771_effa_4326_3664, 0xcbea_f48b_3a06_24c3, 0x92d1_5e7d_ceef_1665, 0x1d1a_ab4e_c1cd_6788]),
                Fp::from_raw([0x1563_9415_f6e8_5ef1, 0x7587_2c39_b59a_31f6, 0x51e0_cbea_d655_16b9, 0x3bf7_6308_6a18_9364])
            ]
        ];

        const T: usize = 3;
        let mut grain = Grain::new(super::super::grain::SboxType::Pow, T as u16, 8, 56);

        // Skip over the bits the reference implementation uses to generate the round constants
        for _ in 0..103020 {
            grain.next();
        }
        let (mds, mds_inv) = generate_mds::<Fp, T>(&mut grain, 0);
        assert_eq!(mds, mds_testvector);

        // TODO: don't generate, use the thing production code uses
    }

    #[test]
    fn poseidon_mds() {
        const T: usize = 3;
        let mut grain = Grain::new(super::super::grain::SboxType::Pow, T as u16, 8, 56);
        let (mds, mds_inv) = generate_mds::<Fp, T>(&mut grain, 0);

        // Verify that MDS * MDS^-1 = I.
        #[allow(clippy::needless_range_loop)]
        for i in 0..T {
            for j in 0..T {
                let expected = if i == j { Fp::one() } else { Fp::zero() };
                assert_eq!(
                    (0..T).fold(Fp::zero(), |acc, k| acc + (mds[i][k] * mds_inv[k][j])),
                    expected
                );
            }
        }
    }
}
